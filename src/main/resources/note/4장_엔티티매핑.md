

4장 엔티티 매핑
================

객체와 테이블 매핑
---------------------------------
-  @Entity
-  @Table

 기본 키 매핑
-------------------------------------
-  @Id

#### 기본키 전략
+ 직접 할당 : 기본키를 애플리케이션에서 직접 할당
+ 자동 생성:
    + IDENTITY: 기본 키 생성을 DB에 위임
    + SEQUENCE: 데이터베이스 시퀀스를 사용해서 기본 키를 할당
    + TABLE: 키 생성 테이블을 사용

- IDENTITY 전략

>  **Note**
  IDENTITY 전략은 DB에 INSERT 한 후에 기본 키 값을 조회 할 수 있다.
  JDBC3에 추가된 Statement.getGeneratedKeys() 를 사용하면 데이터를 저장하면서    동시에 생성된 기본 키값도 얻어올 수 있다.
 하이버네이트는 이 메소드를 사용해서 DB와 한 번만 통신할 수 있다.

> **Warning**
 엔티티가 영속 상태가 되려면 식별자가 반드시 필요하다. 그런데 IDENTITY 식별자 생성 전략은 엔티티를 데이터베이스에
저장해야 식별자를 구할 수 있으므로 em.persist()를 호출하는 즉시 INSERT SQL이 데이터베이스에 전달된다.
따라서 이 전략은 트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다.



- sequence 전략
> ** peprsist() 수행 시 절차**
1. 데이터베이스 시퀀를 사용해서 식별자를 조회 (DB조회)
2. 조회한 식별자를 엔티티에 할당
4. 엔티티를 영속성 커넽ㄱ스트에 저장
5. 트랜잭션을 커밋해서 플러시가 일어나면 엔티티를 데이터베이스에 저장.
6.

3. persist를 수행한다.

```java
@Entity
@SequenceGenerator(
	name="BOAD_SEQ_GENERATOR",
	sequenceName ="BOARD_SEQ"
	initialValue=1, allocationSize=1)
public class Board{

	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE,
					generator = "generator = "BOARD_SEQ_GENERATOR"")
}
```
name:
sequenceName:
initialValue
allocationSize:  시퀀스 한 번 호출에 증가하는 수 (성능 최적화에 사용됨) / default: 50 -> DB에서 1로되어있으면 1로.
 성능향상을 위해서 default 로 50으로 설정되어있다. 한번 sequence를 50 증가시키며 가져와서 1~50까지를 메모리에서 할당한다.


>

 필드와 컬럼 매핑
---------------------
-  @Column


**@Access**
- 필드 접근 : AccessType.FIELD 필드에 직접 접근한다. 필드 접근 권한이  private어도 접근할 수 있다.
  클래스에 설정.
